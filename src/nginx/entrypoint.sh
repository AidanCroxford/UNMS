#!/usr/bin/dumb-init /bin/sh

set -e

echo "Running entrypoint.sh"
uid=${NGINX_UID:-1000}

# do this only once after creating the container
if ! id -u unms &>/dev/null; then

  # create unms user that will own nginx
  echo "Creating user unms with UID ${uid}"
  adduser -D -u "${uid}" unms

  # create directory for LetsEncrypt acme-challenge
  echo "Creating /www directory"
  mkdir /www
  chown unms /www

  # determine local network address
  export LOCAL_NETWORK=$(ip route | tail -1 | cut -d' ' -f1) || true

  # create Nginx config files from templates
  echo "Creating Nginx config files"
  rm -f /etc/nginx/conf.d/*
  /fill-template.sh "/nginx.conf.template" "/etc/nginx/nginx.conf"

  WS_PORT=${WS_PORT:-${HTTPS_PORT}}
  if [ "${WS_PORT}" = "${HTTPS_PORT}" ]; then
    /fill-template.sh "/combined.conf.template" "/etc/nginx/conf.d/combined.conf"
  else
    /fill-template.sh "/https.conf.template" "/etc/nginx/conf.d/https.conf"
    /fill-template.sh "/wss.conf.template" "/etc/nginx/conf.d/wss.conf"
  fi

  # Delete the Let's Encrypt accounts directory if this is the first time that we run UNMS with integrated nginx.
  # This is necessary because the 'accounts/.../regr.json' file previously generated by the npm library
  # is incompatible with the certbot tool in unms-nginx.
  if [ -z "${SSL_CERT}" ] && [ ! -f "/cert/live.crt" ] && [ -d "/cert/accounts" ]; then
    echo "Deleting old LetsEncrypt 'accounts' directory"
    rm -rf /cert/accounts
  fi

  # If a self signed certificate exists from UNMS versins without integrated nginx, reuse it. This is necessary,
  # because UNMS UI will report an update failure if the certificate changes after the update.
  # This requires determining the Common Name and renaming the certificate files.
  if [ -z "${SSL_CERT}" ] && [ -f "/cert/self-signed.crt" ] && [ -f "/cert/self-signed.key" ]; then
    echo "Found old certificate files, extracting Common Name..."
    commonName=$(openssl x509 -noout -subject -in /cert/self-signed.crt 2>/dev/null | sed -n '/^subject/s/^.*CN=//p' || true)
    if [ ! -z "${commonName}" ]; then
      echo "Renaming old certificate files from 'self-signed' to '${commonName}'"
      mv -f "/cert/self-signed.crt" "/cert/${commonName}.crt" || echo "Failed to rename self-signed.crt to ${commonName}.crt"
      mv -f "/cert/self-signed.key" "/cert/${commonName}.key" || echo "Failed to rename self-signed.key to ${commonName}.key"
    else
      echo "Failed to extract Common Name from old certificate file, will not reuse"
    fi
  fi

fi

# generate self-signed SSL certificate if none is provided or existing
if [ -z "${SSL_CERT}" ]; then
  if [ -f /cert/live.crt ] && [ -f /cert/live.key ]; then
    echo "Will use existing SSL certificate"
  else
    echo "Generating self-signed certificate without domain names"
    SAN="DNS:localhost" openssl req -nodes -x509 -newkey "rsa:2048" -subj "/CN=localhost" -keyout "/cert/live.key" -out "/cert/live.crt" -days "36500" -batch -config "openssl.cnf"
    chown -R unms /cert/*
  fi
else
  echo "Will use custom SSL certificate"
  cp -a "/usercert/${SSL_CERT_KEY}" /cert/live.key
  if [ -z "${SSL_CERT_CA}" ]; then
    cp -a "/usercert/${SSL_CERT}" /cert/live.crt
  else
    # Unlike previous nodejs implementation, nginx needs certificate and chain
    # in one file.
    echo "Joining '/usercert/${SSL_CERT}' and '/usercert/${SSL_CERT_CA}' into '/cert/live.crt'"
    cat "/usercert/${SSL_CERT}" "/usercert/${SSL_CERT_CA}" > /cert/live.crt
  fi
fi

echo "Entrypoint finished"
echo "Calling exec $*"
exec "$@"
